# Defines all the components needed by a node
# Tile, Network-on-Chip (NOC)

import sys
import config as cfg
import constants as param

# define an noc class - deals with data transfers between tiles
# 1. send_queue in each tile is a prt of noc
# 2. noc class here does the decoding part
class noc (object):

    def __init__ (self):

        self.start_cycle = 0

        # define num_access (both inter and intra node)
        self.num_cycles_intra = 0 # number of cycles intra_noc was non-idle
        self.num_access_intra = 0 # number of times intra_noc was accessed
        self.num_access_inter = 0 # number of times inter_noc was accessed

        # define latency
        self.latency_intra = param.noc_intra_lat
        self.latency_inter = param.noc_inter_lat

    # Checks if souce and destination tiles belong to the same node
    def check_inter (self, src_tileId, dest_tileId):
        inter_flag = 1
        src_nodeId = (src_tileId-2) / int(cfg.num_tile_max) # integer division (first 2 tiles are i/o tiles)
        dest_nodeId = (dest_tileId-2) / int(cfg.num_tile_max)

        # Note: Input (Output) dummy tile are assumed to communicate (communicated) by intra-node NoC
        #if ((src_tileId == 0) or (dest_tileId == 1) or (src_nodeId == dest_nodeId)): # use this for intermediate layers
        if ((src_tileId == 0) or (dest_tileId == 1) or (src_nodeId == dest_nodeId)): # use this for layer1
        #if ((src_tileId != 0) and ((dest_tileId == 1) or (src_nodeId == dest_nodeId))): # use this for layer1
            inter_flag = 0
        return inter_flag

    # Choose data transfer latency based on inter_flag
    def getLatency (self, target_addr, src_tileId):
        inter_flag = self.check_inter (src_tileId, target_addr)
        if (inter_flag == 1):
            #print ('HT occuring', target_addr, src_tileId)
            return (self.latency_inter + self.latency_intra)
        return self.latency_intra

    # target addr is same as dest_tileId (tiles are numbered from 0 to num_node*num_tile+1) -- includes 2 dummy tiles
    def propagate (self, target_addr, src_tileId):
        ## Based on flag add to NoC (intra) or HT (inter) access
        #inter_flag = self.check_inter (src_tileId, target_addr)
        #if (inter_flag == 1):
        #    print ('inter node ' + str(src_tileId) + ' ' + str(target_addr))
        #    self.num_access_inter += 1
        #self.num_access_intra += 1

        # Check if target address is supported by the DPE configuration
        assert ((type(target_addr) == int) and \
                (target_addr <= cfg.num_node * (cfg.num_tile_compute + 2))), \
                'target addr is invalid - check format and length'
        return target_addr

    # Propagate_count just adds to inter_noc access (router power) or ht access based on src & dest address
    # target addr is same as dest_tileId (tiles are numbered from 0 to num_node*num_tile+1) -- includes 2 dummy tiles
    def propagate_count (self, target_addr, src_tileId):
        # Based on flag add to NoC (intra) or HT (inter) access
        inter_flag = self.check_inter (src_tileId, target_addr)
        if (inter_flag == 1):
            print ('inter node ' + str(src_tileId) + ' ' + str(target_addr))
            self.num_access_inter += 1
        self.num_access_intra += 1

    def start_noc (self, cycle):
        self.start_cycle = cycle

    def stop_noc (self, cycle):
        self.num_cycles_intra += (cycle - self.start_cycle+1)

